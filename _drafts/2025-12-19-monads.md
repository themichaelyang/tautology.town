---
layout: post
title: "Javascript is full of monads"
---

<script defer src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-svg.js"></script>

*I think* I figured out what a monad is, and [now I can't stop seeing them everywhere](https://en.wikipedia.org/wiki/Frequency_illusion).

Javascript is full of monads:

- Promises are monads (and functors) via `.then()`
- `async/await` is [do-notation](https://en.wikibooks.org/wiki/Haskell/do_notation) for Promises
- Arrays are functors via `.map()` and monads via `.flatMap()`
- Optional chaining (`?.`) makes property access a Maybe monad

## You too can see monads

I was thinking about error handling and revisited Scott Wlaschin's amazing [Railroad Oriented Programming](https://fsharpforfunandprofit.com/rop/), which set me back down this path. Scott recommended reading the original monad paper by Philip Wadler: [Monads for functional programming](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf). 

So I did. It's really well written, and not so scary, just as Scott said.

The hardest part for me was Haskell notation: things are written [infix](https://en.wikipedia.org/wiki/Infix_notation), bind is `>>=`, functions are [curried](https://javascript.info/currying-partials), ordering is implicit without parentheses, the lambda notation is weird. I spent much of my time learning the notation and translating concepts.

- `M a` roughly means `M<A>` in Typescript or Java
- $$m \lambda a . n$$ means `((a) => n)(m)`

Some stuff doesn't translate cleanly since Haskell's type system too powerful.

If you set down this path, remember: `fmap` is short for "functor map" and not "flat map". Functor `fmap` is `map` for Arrays, whereas `flatMap` for Arrays is monadic `bind`.

## Are monads [burritos](https://blog.plover.com/prog/burritos.html) or boxes?

The biggest "unlock" for me was not thinking of a monad as a container with a value(s), but as a *type with a generic*. Reading the paper helped me understand this. The container metaphor made it more confusing for me for Arrays (i.e. is it a many boxes each with a value, or a box with many values?).

The [formal definition](https://en.wikipedia.org/wiki/Monad_(functional_programming)#Overview) is short. 
A monad is any type `M<A>` with the following functions:
- `unit(a: A) => M<A>`, i.e. a constructor or factory
- `bind(m: M<A>, fn: (a: A) => M<B>): M<B>`, i.e. `flatMap()` for `Array`

From `bind()`, we can implement `map(m: M<A>, fn: (a: A) => B): M<B>`. A functor is any type with this `map` signature, so monads are functors.

Promises are [Thenable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables) and `then()` is equivalent to `bind()`, so Promises are monads. 

Moreso than a burrito, a monad is a generalization of Thenable. Maybe Scott would say monads are railroads.

There are [many theories on monad pedagogy](https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/) but mine is that monads are a concept made way harder by everything surrounding it. Currying is cool, but it makes a function harder to understand if you've never seen currying. Unfamiliar notation and abstraction in the usual introductions creates cognitive overload that distracts from learning about the actual topic. 
